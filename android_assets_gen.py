import os
import re
import sys
from collections import defaultdict 

def get_all_file_paths(folder_path):
    """
    Retrieves a list of all file paths within a given folder and its subfolders.

    Args:
        folder_path (str): The path to the folder.

    Returns:
        list: A list of strings, where each string is the absolute path to a file.
              Returns an empty list if the folder_path is invalid or not a directory.
    """
    file_paths = []
    # Check if the provided path is a valid directory
    if not os.path.isdir(folder_path):
        print(f"Error: '{folder_path}' is not a valid directory.")
        return file_paths

    # Walk through the directory tree
    for root, directories, files in os.walk(folder_path):
        for filename in files:
            # Construct the full filepath by joining the root directory and filename
            if filename != ".DS_Store":
                filepath = os.path.join(root, filename)
                file_paths.append(filepath)
    return file_paths

def group_files_by_folder(file_paths_list):
    """
    Groups a list of file paths by their parent directory.

    Args:
        file_paths_list (list): A list of absolute file paths.

    Returns:
        dict: A dictionary where keys are absolute directory paths (ending with a path separator)
              and values are lists of filenames found directly in that directory.
    """
    grouped_files = defaultdict(list)
    if not file_paths_list:
        return {} # Return an empty dictionary if the input list is empty

    for f_path in file_paths_list:
        # Get the directory path of the file
        folder_path = os.path.dirname(f_path)
        
        # Ensure the folder path ends with a separator for consistency in keys
        # e.g., /path/to/folder/
        if not folder_path.endswith(os.sep):
            folder_path += os.sep
        
        # Get the base filename
        filename = os.path.basename(f_path)
        
        grouped_files[folder_path].append(filename)
        
    return dict(grouped_files) # Convert defaultdict to a standard dict for the final output

def child_folder_assets(input_str):
    """
    Splits a string after the first occurrence of "assets/".
    Returns the portion of the string after "assets/".
    If "assets/" is not found, it returns an empty string or handles the error.
    """
    delimiter = "assets/"
    try:
        # Split the string by the delimiter, a maximum of 1 split
        # The result is a list, and the part after the delimiter is the second element ([1])
        return input_str.split(delimiter, 1)[1]
    except IndexError:
        return ""

def get_uppercase_name(filename):
  """
  Extracts the name from a filename (without extension) and converts it to uppercase.

  Args:
    filename: The name of the file (string).

  Returns:
    The uppercase name without the extension (string).
  """
  name_without_extension, _ = os.path.splitext(filename)
  uppercase_name = name_without_extension.replace(" ", "_").replace("-", "_").upper()
  return uppercase_name

def convert_to_capitalized_class_name(input_string):
  """
  Converts a string to Capitalized Case suitable for class names.

  It handles various separators like underscores, spaces, and slashes.

  Args:
    input_string: The input string to convert.

  Returns:
    The string in Capitalized Case.
  """
  # Remove any trailing slashes
  cleaned_string = input_string.rstrip('/')
  # Split the string by non-alphanumeric characters (underscores, spaces, slashes, etc.)
  words = re.split(r'[^a-zA-Z0-9]+', cleaned_string)
  # Capitalize the first letter of each word and join them
  capitalized_words = [word[0].upper() + word[1:] for word in words]
  return "".join(capitalized_words)

def create_enum_class_kotlin(package_name, child_folder, files_in_folder): 
    """
    Creates a Kotlin enum class based on the files in a given folder.

    Args:
        folder_path (str): The path to the folder.
        files_in_folder (list): A list of filenames in that folder.
    """
    class_name = convert_to_capitalized_class_name(child_folder)

    enum_list = [f"    {get_uppercase_name(item)}(\"{item}\")" for item in files_in_folder]
    enum_list_str = ",\n".join(enum_list)
    
    return """/// GENERATED CODE - DO NOT MODIFY BY HAND
/// *****************************************************
///  Android assets gen file
///  Generated by android_assets_gen.py
/// *****************************************************

package [PACKAGE_NAME]
import android.net.Uri

enum class [CLASS_NAME](val fileName: String) {
[ENUM_LIST]
}

fun [CLASS_NAME].path() = "[CHILD_FOLDER]${this.fileName}"

fun [CLASS_NAME].toUri(): Uri = Uri.parse("file:///android_asset/${path()}")

""".replace("[PACKAGE_NAME]", package_name).replace("[CLASS_NAME]", class_name).replace("[ENUM_LIST]", enum_list_str).replace("[CHILD_FOLDER]", child_folder) 
         
def write_file(filename, content):
  """
  Writes the given content string to a file with the specified filename.

  Args:
    filename: The name of the file to create or overwrite (string).
    content: The string content to write to the file.
  """
  try:
    with open(filename, 'w') as file:
      file.write(content)
    print(f"Successfully wrote content to '{filename}'")
  except Exception as e:
    print(f"An error occurred while writing to '{filename}': {e}")

def create_child_folder(parent_path, child_folder_name):
  """Creates a child folder within a specified parent folder.

  Args:
    parent_path: The path to the parent directory.
    child_folder_name: The name of the child folder to create.
  """
  child_path = os.path.join(parent_path, child_folder_name)
  try:
    os.makedirs(child_path, exist_ok=True)
    print(f"Successfully created folder: {child_path}")
  except OSError as e:
    print(f"Error creating folder {child_path}: {e}")

def write_enum_class(output_folder_path, package_name, folder_path, files_in_folder):
    """
    Handles the printing of files in a folder.

    Args:
        folder_path (str): The path to the folder.
        files_in_folder (list): A list of filenames in that folder.
    """
    child_folder = child_folder_assets(folder_path)

    if len(files_in_folder) > 0 and len(child_folder) > 0:
        class_name = convert_to_capitalized_class_name(child_folder)
        kotlin_file_name = f"{class_name}.kt"
        enum_class_content = create_enum_class_kotlin(package_name, child_folder, files_in_folder)
        write_file(output_folder_path + kotlin_file_name, enum_class_content)
    

if __name__ == "__main__":
    
    package_name_app = ""
    
    if len(sys.argv) > 0:
        package_name_app = sys.argv[1].strip()
    else:
        package_name_app = input("Enter the package name: ").strip()

    package_name_output_folder = 'gen'
    input_folder_path = "app/src/main/assets"
    output_folder_path = "app/src/main/java/" + package_name_app.replace(".", "/")
    create_child_folder(output_folder_path, package_name_output_folder)
    default_output_folder = output_folder_path + f"/{package_name_output_folder}/"

    # Get all file paths
    all_files = get_all_file_paths(input_folder_path)

    # Print the individual file paths and then the grouped results
    if all_files:
        # Group the files by their respective folders
        grouped_by_folder = group_files_by_folder(all_files)
        
        if grouped_by_folder:
            package_name = package_name_app + "." + package_name_output_folder
            for i, (folder, files_in_folder) in enumerate(grouped_by_folder.items()):
                write_enum_class(default_output_folder, package_name, folder, files_in_folder)
          
        else:
            print("Empty dictionary") 

    elif os.path.isdir(input_folder_path): 
        print(f"No files found in '{input_folder_path}'.")
    # If the path was invalid, get_all_file_paths would have printed an error already.
